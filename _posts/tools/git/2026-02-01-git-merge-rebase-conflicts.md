git fetch origin
git rebase origin/main
git switch main
git merge --no-ff feature/foo
---
title: "Git 合并与变基：算法、冲突类型与解决剧本"
date: 2026-02-01 11:10:00 +08:00
categories: [Tools, Dev]
tags: [git, merge, rebase, conflict, rerere]
image: /assets/img/og-cover.svg
---

> 定位：本篇只讨论「合并/变基策略、冲突类型与解决剧本」。不覆盖提交规范、回退、PR/CI、分支模型（在系列其他文章）。目标是弄清楚：Git 背后如何做三方合并；常见冲突长什么样；遇到棘手场景时如何自救与预防。

## 1. 合并与变基的本质
- merge：创建一个新的合并提交，保留两个父节点；历史呈现菱形，信息保留「何时融合」。
- rebase：取一系列提交，重新应用到目标分支末尾；历史线性，像是「把补丁重放到新底座」。
- 决策提示：
  - 需要追踪合并点、多人长期并行 → merge（建议 `--no-ff` 保留节点）。
  - 需要线性历史、便于 bisect → rebase（在私人分支或团队允许的场景）。
  - 合并 release/hotfix 时更关注溯源 → merge；特性分支短小且未共享 → rebase。

## 2. Git 三方合并简述（为什么会冲突）
- 基准提交（merge base）决定了冲突对比的共同祖先。
- 当同一行或同一块逻辑在两个分支上都被修改且无法自动合并时，就会出现冲突标记。
- 目录重命名或文件移动时，Git 依靠启发式检测，可能导致「伪冲突」或「未检测到移动」；因此需要人工判断。

## 3. 冲突类型分类与应对要点
- 文本同位置冲突：最常见，查看双方意图，手工合成第三种方案。
- 顺序/插入冲突：同一列表两侧插入不同元素；可按业务优先级或稳定排序合并。
- 删除 vs 修改：一侧删除、一侧修改；需决定是否恢复被删逻辑或改为新实现。
- 文件移动冲突：一侧移动文件，另一侧修改内容；优先保留移动后的路径，融合内容。
- 目录重命名冲突：需要结合 `git status` 输出与历史，手动决定新路径。
- 二进制冲突：无法自动合并，只能选其一或重建；尽量避免把产物放仓库。

## 4. 解决冲突的标准流程（不含提交规范）
1) `git status` 明确冲突文件列表；用 `git diff --name-only --diff-filter=U` 快速查看。
2) 打开冲突文件，理解双方意图；必要时查 `git log --oneline -- <file>` 看最近改动。
3) 决定保留/合并策略，必要时写出第三种实现；避免简单「全选 ours/theirs」导致隐藏缺陷。
4) 对于删除/重命名场景，优先检查是否有依赖文件/引用需要同步更新。
5) 本地验证：编译、单测、关键路径手测；注意运行格式化避免混入无关差异。
6) `git add <file>` 标记解决，继续 rebase/merge；若想放弃，`git merge --abort` 或 `git rebase --abort`。

## 5. rerere：重复冲突自动记忆
```bash
git config --global rerere.enabled true
```
- 原理：记录你对某个冲突的解决方式，下次出现相同冲突会自动套用。
- 适用：大分支频繁 rebase、长周期 release 需要多次合并主干。
- 建议：开启后配合「小步解决+立即验证」；若误解，`git rerere clear` 清除缓存。

## 6. 合并策略选项与使用场景
- `--no-ff`：即使可以 fast-forward，也生成合并提交；用于保留特性节点。
- `-X ours` / `-X theirs`：冲突时偏向一方（仅在少量无关文件冲突时谨慎使用，不要盲目覆盖业务代码）。
- `--strategy=ours`：整合并提交但完全采用当前分支内容，多用于「暂时放弃另一分支」的占位，但未来可能埋雷，慎用。
- `--strategy=recursive -X patience`：对大规模重排或换行的文件更友好，减少伪冲突。
- octopus merge（多父）：适合一次合入多个独立分支；若有冲突会失败，需逐个合并。

## 7. .gitattributes 与合并驱动
- 声明文本/二进制：`*.png binary` 避免伪合并。
- 自定义合并驱动：为特定文件定义合并策略，如锁文件 `package-lock.json` 可尝试 `merge=union`，配置文件可用自定义脚本。
- 正常化行尾/编码：减少因为 CRLF/LF 导致的伪冲突。
- 路径级别的 ours/theirs：对某些生成文件可设定始终采用一侧，降低噪音；但要在团队内达成共识并写入文档。

## 8. 重命名与移动的特殊处理
- Git 通过内容相似度检测重命名，阈值默认 50%；可用 `-M` 调整，如 `git diff -M70%`。
- 当一侧改名、一侧修改：
  - 先在新路径应用修改，再删除旧路径，保证引用更新。
  - 用 `git log --follow new/path` 追踪历史，确保不丢上下文。
- 大规模重命名建议：
  - 先独立提交「纯重命名+格式化」，不夹杂逻辑；
  - 在后续提交里做行为变更，减少合并冲突与审查成本。

## 9. 典型棘手场景剧本
- 场景 A：两个团队改同一 JSON 配置顺序。
  - 启动 `-X patience` 合并；若仍冲突，用统一排序（如键排序）脚本规范化；把脚本写入 pre-commit。
- 场景 B：release 分支与主干同时迭代同一功能。
  - 为 release 功能打开特性开关，主干继续演进；合并时先主干 rebase release，关闭开关回归统一路径。
- 场景 C：子模块指针与父仓库同时改动。
  - 先在子模块内部解决冲突并推送，再回父仓库更新指针；合并时优先确保子模块可 checkout。
- 场景 D：文档/二进制大文件冲突。
  - 对文档可用在线协作工具先合并内容，再回写仓库；二进制尽量移出仓库或用 LFS；无法自动合并时人工挑选并备注来源。

## 10. 冲突预防清单（与其他文章不重复）
- 规划层面：公共文件设 owner，变更前先开 issue/公告；对跨团队改动设「冻结窗口」。
- 代码结构：拆模块、明确边界，避免多人踩同一目录；提供稳定的扩展点而不是硬改核心文件。
- 工具侧：统一格式化/排序；在 CI 中运行 `git merge --no-commit --no-ff origin/main` 预检测冲突（仅在镜像分支环境执行）。
- 分支节奏：对长分支每周固定一次「同步日」，提前消化冲突而不是最后集中爆炸。

## 11. 观测与指标
- 冲突率：有冲突的合并占比；高说明分支过长或公共文件治理差。
- 解决耗时：从遇到冲突到合并完成的时间；用于衡量预案效率。
- 返工率：冲突解决后引入的新缺陷数；提醒需要更多验证或改进合并策略。
- 热点文件：高冲突文件列表，驱动模块拆分或责任人机制。

## 12. 自我演练与练习
- 演练 1：制造一个「删除 vs 修改」冲突，练习决定保留方案并写下验证步骤。
- 演练 2：在同一文件两端插入不同逻辑，使用 `-X patience` 观察差异，体会策略效果。
- 演练 3：开启 rerere，在大分支上重复 rebase，感受自动解决的收益与限制。
- 演练 4：为仓库设置 `.gitattributes`，对锁文件/二进制/文档设定策略，并验证冲突行为。

## 13. 行动清单
- 立刻：开启 `rerere`，写下团队的合并策略指南；为公共文件指定 owner。
- 本周：补 `.gitattributes`，对二进制和锁文件设定合适策略；用「重命名独立提交」方式整理易冲突目录。
- 本月：在 CI 加入一次预合并检查（沙箱分支），统计冲突率与耗时，驱动结构化改进。

## 14. 结语
冲突不可避免，但可管理。理解合并算法、分类冲突场景、准备好剧本和工具，就能把冲突从「事故」变成「流程性工作」。

## 15. 语义冲突与事后验证
- 语义冲突：代码能自动合并但行为被破坏（例如双方都改了条件，组合后逻辑错误）。
- 预防：
  - 增加契约测试/集成测试；
  - 对公共逻辑改动要求对称改动（客户端 + 服务端 + 文档）；
  - 评审时关注交互行为而非仅看 diff。
- 事后验证：在合并流水线中运行「关键路径冒烟脚本」，尽早暴露语义冲突。

## 16. Monorepo 场景的合并策略
- 路径独立：不同服务之间改动解耦，可用按路径触发的 CI 与 Reviewer；减少无关冲突。
- 垂直切片：同一业务链的多服务改动，采用「契约先行 + 短期集成分支」，避免主干不兼容。
- 模块重构：先提交「兼容层」与「双写」；大规模替换后再清理旧路径，分阶段降低冲突风险。

## 17. 工具与命令速查（扩展）
- 预检冲突：`git fetch origin && git merge --no-commit --no-ff origin/main`（在临时分支执行，结束后 `git merge --abort`）。
- 比较两种合并方式：`git range-diff origin/main...HEAD origin/main...feature/rebase-version`。
- 查看 rerere 缓存：`git rerere status`，清除：`git rerere clear`。
- 解决后自检：`git diff --check` 捕获残留空白/冲突标记；`git log --merge` 仅看与合并相关提交。

## 18. 目录重构的分阶段剧本
1) 提交 A（纯移动/重命名）：确保编译、测试通过；无行为改动。
2) 提交 B（更新引用与导入）：调整路径、包名、构建脚本；仍保持行为不变。
3) 提交 C（功能改动/重构）：在新结构上开发；分批合并主干，减少后续冲突。
4) 验证：在每个阶段后跑完整度检查（依赖树、构建、契约测试），避免累计错误。

## 19. 大规模合并作战手册
- 角色分工：一人负责主干同步，一人负责冲突解决，一人负责测试回归；减少“大家一起改”的混乱。
- 切片策略：按子模块或功能旗标拆 PR，逐步合入；避免“一口吞”导致评审与冲突暴增。
- 节奏：设定每日同步主干与测试窗口；合并日之前锁定新功能，专注解决遗留冲突。
- 沟通：每日更新冲突热点、完成度与风险；必要时对公共文件设「合并冻结」。

## 20. 训练题（自测）
- 题 1：双方在同一函数增加不同参数默认值，如何合并并保持兼容？
- 题 2：一个分支删除字段，另一个分支在该字段上加校验。如何决策？需要补什么测试？
- 题 3：子模块指针更新后，父仓库 merge 时冲突，你会如何操作？
- 题 4：如何利用 `range-diff` 比较 rebase 版本与原始分支的差异，确认没有丢提交？

## 21. 行动清单（扩展）
- 立刻：为仓库补充冲突解决指南和工具速查，加入 rerere 与 `.gitattributes` 示例。
- 本周：对冲突高发目录执行「重命名独立提交」重排；在 CI 增加预检冲突的沙箱步骤（仅报告不阻塞）。
- 本月：组织一次冲突演练，包含二进制、重命名、删除 vs 修改等场景；收集耗时与痛点，制定改进计划。
